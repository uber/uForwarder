service:
  name: ${UDEPLOY_SERVICE_NAME:kafka-consumer-proxy}

logging:
  pattern:
    level: "%X"

# GRPC Server configurations
grpc:
  # Port for GRPC Server
  port: 0

server:
  # Port for jetty
  port: 0

system:
  port: 0

# These are the configurations for the system debug pages.
management:
  # These configurations manage the jobs.html debug pages
  job:
    enabled: true
  # These configurations manage the workers.html debug pages
  worker:
    enabled: true
    # workerUdg sets the udg path for the worker to link to worker debug page from master debug page.
    workerUdg: "udg://kafka-consumer-proxy-worker"

# These are the configurations for the master
master:
  rebalancer:
    mode: StreamingRpcUriRebalancer
    numWorkersPerUri: 1
  autoscalar:
    enabled: true
    sampleInterval: 5000
  jobCreator: default
  # These are configurations that control Kafka related operations
  kafka:
    # Determines the frequency of checking kafka topic partition expansion or shrink.
    # When partition expansion or shrink happens, the master will create new jobs or destroy old
    # jobs.
    partition.expansion.watcher.interval: 60000 # 1 min in ms
    # These are the configurations for the Kafka AdminClient.
    admin:
      # This determines how we will resolve the kafka brokers.
      resolverClass: com.uber.data.kafka.datatransfer.common.StreamingCommonKafkaClusterResolver
      # According to Kafka, the client ID should be unique in a Kafka consumer proxy instance.
      clientId: kafka-consumer-proxy-admin-test
      # This is the bootstrap server that is used if resovlerMode = STATIC.
      bootstrapServers: 127.0.0.1:9093
      # This determines whether or not to load secure configuration for kafka admin client
      enableSecure: true
    # These are the configurations for the KafkaConsumer used to commit offsets for all
    # topic-partitions.
    offsetCommitter:
      # This determines how we will resolve the kafka brokers.
      resolverClass: com.uber.data.kafka.datatransfer.common.StreamingCommonKafkaClusterResolver
      # This is the bootstrap server that is used if resovlerMode = STATIC.
      bootstrapServers: 127.0.0.1:9093
  # These are configurations that control the managers.
  # Managers are responsible for maintain the state of the system, but defer persistent to the store.
  manager:
    job:
      # Determines the frequency of emitting metrics on job state.
      metricsInterval: 60000 # 1 min in ms
      # Determines the frequency that the rebalance loop is run.
      # Reducing this value means that system will detect unassigned jobs faster
      # but at the cost of additional store calls.
      rebalanceInterval: 10000 # 10s in ms
    worker:
      # Determines the frequency of emitting metrics on worker state.
      metricsInterval: 60000 # 1 min in ms
  # These configurations control the store.
  store:
    mode: ZK
    worker:
      # This sets the worker TTL.
      # If a worker misses heartbeats for this amount of time, the work will be reassigned to another worker.
      ttl: 2m
    jobStatus:
      # This sets the interval for async/batched writes to underlying storage.
      # Internally, this class maintains an in-memory WAL that is periodically written to ZK in a batch.
      asyncWriteInterval: 10s
      # This sets the job status TTL.
      ttl: 5m
  zookeeper:
    # This sets the zkConnection
    # coordinator uses zkConnection for leader election
    # If store.mode is ZK, it will read connection string from zkConnection
    zkConnection: 127.0.0.1:2181/kafka-consumer-proxy
  coordinator:
    leaderSelector:
      # Determines the frequency of emitting metrics on leader selector state.
      metricsInterval: 60000 # 1 min in ms
